module Holidays
  # `RegionModule` contains all of the definitions that fall under a single parent region. This will be used to generate the module
  # source code that will be loaded at runtime to look up holiday information for a region.
  class RegionModule
    attr_reader :name
    attr_reader :definitions

    # The `RegionDefinition`'s provided here should be pre-validated so that they all fall under the same parent region.
    def initialize(name, definitions)
      raise ArgumentError, "RegionModule name cannot be blank" if name.nil? || name.empty?

      @name = name
      @definitions = definitions
    end

    # This will generate a list of `RegionModules` by grouping the provided `RegionDefinitions`
    # according to their regions.
    def self.from_definitions(definitions)
      regions = Hash.new { |hash, key| hash[key] = [] }
      definitions.each do |definition|
        parent_region = definition.region.to_s.split('_').first
        regions[parent_region] << definition
      end

      regions.to_a.map { |kv| RegionModule.new(kv[0], kv[1]) }
    end

    def to_module_source
      regions = definitions.map(&:region).uniq

      month_strings = []
      rules_by_month.each do |month, rules|
        rule_string = rules.map { |rule| rule.to_source(parsed_custom_methods) }.join(",\n            ")
        month_strings <<  "      #{month.to_s} => [#{rule_string}]"
      end

      custom_method_string = ''
      custom_methods.each do |key, code|
        custom_method_string << code.to_source + ",\n\n"
      end
      
      <<-EOM
# encoding: utf-8
module Holidays
  # This file is generated by the Ruby Holidays gem.
  module #{name.to_s.upcase} # :nodoc:
    def self.defined_regions
      [:#{regions.join(', :')}]
    end

    def self.holidays_by_month
      {
          #{month_strings.join(",\n")}
      }
    end

    def self.custom_methods
      {
          #{custom_method_string}
      }
    end
  end
end
      EOM
    end

    def to_test_source
      raise ArgumentError.new("tests for '#{module_name}' cannot be missing") if tests.nil?

      test_source_code = tests.map(&:to_source).join { |source| "\n    #{source}" } 


              <<-EndOfTests
# encoding: utf-8
require File.expand_path(File.dirname(__FILE__)) + '/../test_helper'

# This file is generated by the Ruby Holiday gem.
#
class #{name.to_s.capitalize}DefinitionTests < Test::Unit::TestCase  # :nodoc:

  def test_#{name.to_s.downcase}#{test_source_code}
  end
end
EndOfTests
    end

    # Combine the rules of all inner definitions into a single hash. The keys of this hash are the month indices and the values are list of `HolidayRule`s.
    def rules_by_month
      rules = Hash.new { |hash, key| hash[key] = [] }

      definitions.each do |definition|
        definition.month_rules.each do |month, def_rules|
          rules[month] += def_rules
        end
      end

      rules
    end

    # Returns a hash containing all of the custom methods from the inner definitions. This will do a naive merging of these methods, so duplicates
    # will get overwritten in possibly unpredictable ways.
    def custom_methods
      cm = {}
      definitions.each do |definition|
        cm.merge! definitions.custom_methods
      end

      cm
    end

    def metadata_by_region
      metadata = {}
      definitions.each do |definition|
        metadata[definition.region] = definition.metadata
      end
      metadata
    end

    def tests
      definitions.flat_map { |d| d.tests }
    end

    def regions
      all_regions = [name.to_sym]
      all_regions += definitions.map { |d| d.region.to_sym }
      all_regions.flatten!
      all_regions
    end
  end
end